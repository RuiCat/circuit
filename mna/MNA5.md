# 包含电感器、电容器和运放的改进节点分析

本文档描述了当电路具有电感器、电容器和/或运算放大器（运放）时生成改进节点分析（MNA）方程的算法方法。它由几个部分组成：

## 目录
- 包含无功元件的MNA
- 包含运放的MNA
- 另一个示例
- 继续前进
- 参考文献

## 包含无功元件的MNA

将改进节点分析应用于具有电感器和电容器的电路，如果使用这些元件的复阻抗，则没有特殊困难。
```
ZR = R
ZL = sL = jωL
ZC = 1/(sC) = 1/(jωC)
```

让我们将MNA应用于以下电路（该电路已经标记了节点，并且通过电压源的电流已定义和标记）：

MNA将生成4个方程，三个节点各一个，Vin一个。通过检查我们得到：
```
v_1·s·C1 + v_1/(s·L1) + v_1/R1 + (v_1 - v_2)·s·C2 = 0 (节点1)
(v_2 - v_3)/R2 + (v_2 - v_1)·s·C2 = 0 (节点2)
I_Vin + (v_3 - v_2)/R2 = 0 (节点3)
v_3 = Vin (Vin)
```

使用MNA算法我们得到：
```
G = [s·C1 + s·C2 + 1/(s·L1) + 1/R1, -s·C2, 0;
     -s·C2, s·C2 + 1/R2, -1/R2;
     0, -1/R2, 1/R2]
B = C^T = [0; 0; 1]
D = [0]
A = [s·C1 + s·C2 + 1/(s·L1) + 1/R1, -s·C2, 0, 0;
     -s·C2, s·C2 + 1/R2, -1/R2, 0;
     0, -1/R2, 1/R2, 1;
     0, 0, 1, 0]
v = [v_1; v_2; v_3]
j = [I_Vin]
x = [v_1; v_2; v_3; I_Vin]
i = [0; 0; 0]
e = [Vin]
z = [0; 0; 0; Vin]
```

由于矩阵都已定义，我们现在可以写出最终矩阵：
```
Ax = z
或 [s·C1 + s·C2 + 1/(s·L1) + 1/R1, -s·C2, 0, 0;
    -s·C2, s·C2 + 1/R2, -1/R2, 0;
    0, -1/R2, 1/R2, 1;
    0, 0, 1, 0] * [v_1; v_2; v_3; I_Vin] = [0; 0; 0; Vin]
```

仔细检查这个结果，验证它与原始结果相同。不用担心求解这个方程；后面的页面将介绍SCAM - 一个用于符号推导和求解电路方程的MATLAB工具。

## 包含运放的MNA

将改进节点分析应用于具有理想运算放大器（运放）的电路有点困难。每个运放将电压源计数增加1（因为运放的输出被视为电压源），但也使MNA矩阵的创建复杂化。特别是，B和C矩阵不再是彼此的转置。要了解如何处理理想运算放大器，请考虑下面的电路：

注意我们已经标记了所有节点，并定义了通过每个电压源的电流。通过电压源Vs的电流是I_Vs，进入运放的电压标记为I_OA。我们将对理想运放做标准假设。即设备在运放的任一输入端都没有电流，并且输入之间的电压差为零（注意下面的注意事项）。

这个电路将需要6个方程——4个节点各一个，2个标记电流各一个。我们现在可以通过检查写出电路方程。
```
I_Vs + (v_1 - v_2)/R1 = 0 (节点1)
(v_2 - v_1)/R1 + v_2·s·C1 = 0 (节点2)
v_3/R3 + (v_3 - v_4)/R2 = 0 (节点3)
I_OA + (v_4 - v_3)/R2 = 0 (节点4)
v_1 = Vs (Vs)
v_2 - v_3 = 0 (运放输入)
```

或以矩阵形式：
```
[1/R1, -1/R1, 0, 0, 1, 0;
 -1/R1, 1/R1 + s·C1, 0, 0, 0, 0;
 0, 0, 1/R2 + 1/R3, -1/R2, 0, 0;
 0, 0, -1/R2, 1/R2, 0, 1;
 1, 0, 0, 0, 0, 0;
 0, 1, -1, 0, 0, 0] * [v_1; v_2; v_3; v_4; I_Vs; I_OA] = [0; 0; 0; 0; Vs; 0]
```

这个方程与我们开发的其他方程之间的唯一区别是运放的方程不是根据其输出的电压，而是指定两个输入端子处于相同的电位。

### MNA矩阵形成的变化

**A矩阵**：

回想一下，A矩阵由四个较小的矩阵G、B、C和D组成。

- G矩阵的规则不变。
- B矩阵的规则不变——运放被视为另一个电压源。
- C矩阵的规则确实改变。C矩阵是一个n×m矩阵，只有0、1和-1元素。矩阵中的每个位置对应于一个特定的节点（第一维）或电压源（第二维）。对于每个独立电压源，如果第i个电压源的正端子连接到节点k，则C矩阵中的元素(k,i)是1；如果第i个电压源的负端子连接到节点k，则C矩阵中的元素(k,i)是-1。对于每个运放，让正输入端子位于节点k，负端子位于节点j；C矩阵的相应（第i）行在正端子（k,i）对应的位置有1，在负端子（j,i）对应的位置有-1。否则，C矩阵的元素为零。
- D矩阵的规则不变。

**x矩阵**不变。

**z矩阵**：

回想一下，z矩阵由两个较小的矩阵i和e组成。

- i矩阵的规则不变。
- e矩阵的规则确实改变。e矩阵是一个1×m矩阵，矩阵的每个元素对应于一个电压源。如果e矩阵中的元素对应于独立源，则将其设置为该电压源的值。如果元素对应于运放，则其值设置为零。

**注意事项**：两个理想运放假设（无输入电流，输入无电位差）仅适用于具有负反馈的电路。因此，这里应用的MNA方法如果不存在负反馈，可能会给出错误的结果。这个问题实际上在许多商业电路模拟器中持续存在——您可以连接一个输入端子反转的电路（因此在实践中由于缺乏负反馈而无法正常工作），模拟表现得好像没有问题。还要注意运放的输出不受任何电源限制——这个电路将愉快地产生数百伏。

**另外**：运放规则可以通过利用节点电压中的冗余来简化，因为两个输入节点处于相同的电压。利用这个事实将方程数减少1，尽管它使方程的生成有点困难（G矩阵的对角线可以有负值，非对角线元素可以是正的，C矩阵可以有除了1、-1和0之外的值，D矩阵是非零的）。有关详细信息，请参见Litovski。

让我们将算法应用于手头的电路：

使用算法的规则我们得到：
```
G = [1/R1, -1/R1, 0, 0;
     -1/R1, 1/R1 + s·C1, 0, 0;
     0, 0, 1/R2 + 1/R3, -1/R2;
     0, 0, -1/R2, 1/R2]
B = [1, 0;
     0, 0;
     0, 0;
     0, 1]
C = [1, 0;
     0, 0;
     0, 1;
     0, -1]
D = [0, 0; 0, 0]
A = [1/R1, -1/R1, 0, 0, 1, 0;
     -1/R1, 1/R1 + s·C1, 0, 0, 0, 0;
     0, 0, 1/R2 + 1/R3, -1/R2, 0, 0;
     0, 0, -1/R2, 1/R2, 0, 1;
     1, 0, 0, 0, 0, 0;
     0, 1, -1, 0, 0, 0]
v = [v_1; v_2; v_3; v_4]
j = [I_Vs; I_OA]
x = [v_1; v_2; v_3; v_4; I_Vs; I_OA]
i = [0; 0; 0; 0]
e = [Vs; 0]
z = [0; 0; 0; 0; Vs; 0]
```

将所有内容组合在一起得到：
```
Ax = z
或 [1/R1, -1/R1, 0, 0, 1, 0;
    -1/R1, 1/R1 + s·C1, 0, 0, 0, 0;
    0, 0, 1/R2 + 1/R3, -1/R2, 0, 0;
    0, 0, -1/R2, 1/R2, 0, 1;
    1, 0, 0, 0, 0, 0;
    0, 1, -1, 0, 0, 0] * [v_1; v_2; v_3; v_4; I_Vs; I_OA] = [0; 0; 0; 0; Vs; 0]
```

这个结果，经过检查，与我们之前的结果相同。

## 另一个示例

让我们看另一个简单的示例，只是为了加强概念。

这个电路将只需要3个方程（2个节点，1个电压源）。通过检查我们得到：
```
-Iin + v_1/R1 + (v_1 - v_2)·s·C1 + (v_1 - v_2)/R2 = 0 (节点1)
(v_2 - v_1)·s·C1 + (v_2 - v_1)/R2 + I_OA = 0 (节点2)
v_2 - v_1 = 0 (运放输入)
```

使用我们的MNA算法我们得到：
```
G = [1/R1 + 1/R2 + s·C1, -1/R2 - s·C1;
     -1/R2 - s·C1, 1/R2 + s·C1]
B = [0; 1]
C = [-1; 0]
D = [0]
A = [1/R1 + 1/R2 + s·C1, -1/R2 - s·C1, 0;
     -1/R2 - s·C1, 1/R2 + s·C1, 1;
     -1, 1, 0]
v = [v_1; v_2]
j = [I_OA]
x = [v_1; v_2; I_OA]
i = [Iin; 0]
e = [0]
z = [Iin; 0; 0]
```

我们现在可以使用这些矩阵来求解电路：
```
Ax = z
或 [1/R1 + 1/R2 + s·C1, -1/R2 - s·C1, 0;
    -1/R2 - s·C1, 1/R2 + s·C1, 1;
    -1, 1, 0] * [v_1; v_2; I_OA] = [Iin; 0; 0]
```

这与我们之前的结果一致。

## 继续前进

下一个文档描述了SCAM，一个执行所有这些操作来设置矩阵，然后求解电路的MATLAB程序。

## 参考文献

