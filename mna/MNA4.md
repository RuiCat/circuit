# 改进节点分析示例

本文档描述了一种算法方法，用于生成只有阻抗（电阻）和独立电压源和电流源的系统的改进节点分析（MNA）方程。它由几个部分组成：

## 目录
- 回顾
- 符号
- 示例1
- 示例2
- 示例3
- 参考文献

本文页面的许多思想和符号来自Litovski，但这里的讨论相当简单，因为只考虑无源元件（例如，电阻）独立电压源和电流源。

## 回顾

回顾上一个文档，应用于电路的MNA产生形式为的矩阵方程：
```
Ax = z
```

我们将取n为节点数（不包括地），m为独立电压源数。

## 符号

- 地标记为节点0。
- 其他节点从1到n连续标记。
- 我们将节点1的电压称为v_1，节点2的电压称为v_2，依此类推。
- 独立电压源的命名相当宽松，但名称必须以字母"V"开头，并且必须与任何节点名称不同。对于我们的目的，我们将要求独立电压源在其名称中没有下划线("_")。因此名称Va、Vsource、V1、Vxyz123都是合法的名称，但V_3、V_A、Vsource_1不是。
- 通过电压源的电流将标记为"I_"后跟电压源的名称。因此通过Va的电流是I_Va，通过VSource的电流是I_VSource，等等...
- 独立电流源的命名类似；名称必须以字母"I"开头，并且在其名称中没有下划线("_")。因此名称Ia、Isource、I1、Ixyz123都是合法的名称，但I_3、I_A、Isource_1不是。
- 注意：其中一些规则是任意的（特别是命名约定），但将使基于MATLAB的算法开发更容易。

如果需要，请回顾形成MNA矩阵的规则。

## 示例1

给出的示例来自Smith，图2.8。首先将从电路推导MNA方程。然后根据上一个文档中的算法推导它们——希望结果一致。节点和源已按要求标记，通过电压源的电流已定义（按要求）。

要应用MNA技术，我们将需要5个方程（4个节点各一个，独立电压源一个）。注意Smith只需要2个方程——MNA通常比其他技术需要更多的方程，但适合计算机求解。通过检查我们得到：
```
I_Vbatt + (v_1 - v_2)/R1 = 0 (节点1)
(v_2 - v_1)/R1 + v_2/R4 + (v_3 - v_2)/R2 = 0 (节点2)
(v_2 - v_3)/R2 + v_3/R6 + (v_4 - v_3)/R3 = 0 (节点3)
(v_3 - v_4)/R3 - Isrc = 0 (节点4)
v_1 = Vbatt (电压源)
```

使用算法，我们得到：
```
G = [1/R1, -1/R1, 0, 0;
     -1/R1, 1/R1 + 1/R4 + 1/R2, -1/R2, 0;
     0, -1/R2, 1/R2 + 1/R6 + 1/R3, -1/R3;
     0, 0, -1/R3, 1/R3]
B = C^T = [1; 0; 0; 0]
D = [0]
A = [1/R1, -1/R1, 0, 0, 1;
     -1/R1, 1/R1 + 1/R4 + 1/R2, -1/R2, 0, 0;
     0, -1/R2, 1/R2 + 1/R6 + 1/R3, -1/R3, 0;
     0, 0, -1/R3, 1/R3, 0;
     1, 0, 0, 0, 0]
v = [v_1; v_2; v_3; v_4]
j = [I_Vbatt]
x = [v_1; v_2; v_3; v_4; I_Vbatt]
i = [0; 0; 0; Isrc]
e = [Vbatt]
z = [0; 0; 0; Isrc; Vbatt]
```

将这些组合在一起得到：
```
Ax = z
或 [1/R1, -1/R1, 0, 0, 1;
    -1/R1, 1/R1 + 1/R4 + 1/R2, -1/R2, 0, 0;
    0, -1/R2, 1/R2 + 1/R6 + 1/R3, -1/R3, 0;
    0, 0, -1/R3, 1/R3, 0;
    1, 0, 0, 0, 0] * [v_1; v_2; v_3; v_4; I_Vbatt] = [0; 0; 0; Isrc; Vbatt]
```

仔细比较这个结果与原始结果，验证两个解是相同的。

## 示例2

给出的示例来自Smith，问题2.11。首先将从电路推导MNA方程。然后根据上一个文档中的算法推导它们——希望结果一致。节点和源已按要求标记，通过电压源的电流已定义。

要应用MNA技术，我们将需要3个方程（2个节点各一个，独立电压源一个）。通过检查我们得到：
```
I_Vb + (v_1 - v_2)/R1 = 0 (节点1)
(v_2 - v_1)/R1 + v_2/R2 + v_2/R3 - Is = 0 (节点2)
v_1 = Vb (电压源)
```

使用算法，我们得到：
```
G = [1/R1, -1/R1;
     -1/R1, 1/R1 + 1/R2 + 1/R3]
B = C^T = [1; 0]
D = [0]
A = [1/R1, -1/R1, 1;
     -1/R1, 1/R1 + 1/R2 + 1/R3, 0;
     1, 0, 0]
v = [v_1; v_2]
j = [I_Vb]
x = [v_1; v_2; I_Vb]
i = [0; Is]
e = [Vb]
z = [0; Is; Vb]
```

如果我们将这些结果应用于MNA方程，我们得到
```
Ax = z
或 [1/R1, -1/R1, 1;
    -1/R1, 1/R1 + 1/R2 + 1/R3, 0;
    1, 0, 0] * [v_1; v_2; I_Vb] = [0; Is; Vb]
```

仔细比较这个结果与原始结果，验证两个解是相同的。

## 示例3

最后一个示例涉及更多，它有两个电压源和一个电流源。电流源和其中一个电压源不接地。

首先我们必须标记节点并定义通过电压源的电流

要应用MNA技术，我们将需要5个方程（3个节点各一个，独立电压源两个）。通过检查我们得到：
```
I_Vg + It + (v_1 - v_2)/R1 = 0 (节点1)
-It + (v_2 - v_1)/R1 + v_2/R2 - I_Vx = 0 (节点2)
I_Vx + v_3/R3 = 0 (节点3)
v_1 = Vg (电压源1)
v_3 - v_2 = Vx (电压源2)
```

使用算法我们得到：
```
G = [1/R1, -1/R1, 0;
     -1/R1, 1/R1 + 1/R2, 0;
     0, 0, 1/R3]
B = C^T = [1, 0;
           0, -1;
           0, 1]
D = [0, 0; 0, 0]
A = [1/R1, -1/R1, 0, 1, 0;
     -1/R1, 1/R1 + 1/R2, 0, 0, -1;
     0, 0, 1/R3, 0, 1;
     1, 0, 0, 0, 0;
     0, -1, 1, 0, 0]
v = [v_1; v_2; v_3]
j = [I_Vg; I_Vx]
x = [v_1; v_2; v_3; I_Vg; I_Vx]
i = [-It; It; 0]
e = [Vg; Vx]
z = [-It; It; 0; Vg; Vx]
```

如果我们将这些结果应用于MNA方程，我们得到
```
Ax = z
或 [1/R1, -1/R1, 0, 1, 0;
    -1/R1, 1/R1 + 1/R2, 0, 0, -1;
    0, 0, 1/R3, 0, 1;
    1, 0, 0, 0, 0;
    0, -1, 1, 0, 0] * [v_1; v_2; v_3; I_Vg; I_Vx] = [-It; It; 0; Vg; Vx]
```

仔细比较这个结果与原始结果，验证两个解是相同的。

## 参考文献

- Smith, R. J. (2007). Circuits, Devices, and Systems. John Wiley & Sons.
