# SCAM：MATLAB中的符号电路分析

本文档描述了用于符号推导和求解电路方程的MATLAB®工具。它分为几个部分：

## 目录
- 下载SCAM
- 关于代码
- 为SCAM定义电路：网表
- 示例1：电压
- 示例2：电流
- 示例3：生成MNA方程
- 示例4：更复杂的电路
- 示例5：带电阻的运放
- 示例6：生成MATLAB传递函数对象
- 示例7：查找导线中的电流
- 参考文献

## 下载SCAM

在使用程序之前，您必须首先从GitHub下载它，并将其保存在MATLAB可以访问的计算机上。注意：您必须有符号工具箱才能运行此代码。此页面上描述的示例网表也在GitHub上。

## 关于代码

代码按原样提供，不保证没有错误。如果您确实发现错误，请联系我。

代码编写为MATLAB脚本而不是函数，因为我认为这将使学习更容易，因为它可以逐步执行，并且代码创建的所有变量都出现在工作区中，因此用户可以检查和操作它们。如果您不希望所有变量都在工作区中，只需在顶部添加一行将其转换为函数即可。如果您不希望所有中间结果都打印出来，只需注释掉您不想要的行。

基本上没有错误检查，因此如果您输入不正确的网表，程序将失败而不解释原因。

**符号约定**：

- 地标记为节点0。
- 其他节点从1到n连续标记。
- 我们将节点1的电压称为v_1，节点2的电压称为v_2，依此类推。
- 独立电压源的命名相当宽松，但名称必须以字母"V"开头，并且必须与任何节点名称不同。对于我们的目的，我们将要求独立电压源在其名称中没有下划线("_")。因此名称Va、Vsource、V1、Vxyz123都是合法的名称，但V_3、V_A、Vsource_1不是。
- 通过电压源的电流将标记为"I_"后跟电压源的名称。因此通过Va的电流是I_Va，通过VSource的电流是I_VSource，等等...
- 独立电流源的命名类似；名称必须以字母"I"开头，并且在其名称中没有下划线("_")。因此名称Ia、Isource、I1、Ixyz123都是合法的名称，但I_3、I_A、Isource_1不是。
- 注意：其中一些规则是任意的（特别是命名约定），但将使基于MATLAB的算法开发更容易。

## 为SCAM定义电路：网表

SCAM程序不能简单地读取原理图，因此我们需要开发一种文本表示电路的方法。这可以使用称为网表的设备来完成，它定义电路元件之间的互连。如果您使用过SPICE（具有集成电路重点的模拟程序），这是一个熟悉的概念。宾夕法尼亚大学的Jan Van Der Spiegel提供了一个很好的回顾。这个过程很容易通过示例演示。

让我们使用SCAM分析下面的电路：

我们首先定义节点。这里唯一的限制是节点必须标记为地是节点0，其他节点从1开始连续命名。将哪个数字分配给哪个节点的选择完全是任意的。

SCAM需要一个文本文件，电路中的每个组件一行。这个电路有4个组件（3个电阻和1个电压源），将需要6行来定义它。每种类型的组件在其文件的相应行中都有自己的格式。这些如下所示。标签N1、N2等...对应于电路中的节点。

| 组件类型 | 符号 | SCAM描述 |
|---------|------|-----------|
| 电阻 | R1 N1 N2 1000 | R1在节点N1和N2之间，值为1000欧姆。组件的值必须写出来（没有像kOhm这样的缩写）作为数字。组件的名称是Rx，其中x可以是字母和数字的任何组合。R1、Rabc、Ra1都是有效的名称。 |
| 电容 | C1 N1 N2 1E-6 | 与电阻类似的注释 |
| 电感 | L1 N1 N2 1E-3 | 与电阻类似的注释 |
| 电压源 | V1 N1 N2 12 | 与电阻类似的注释。节点N1连接到正节点，N2连接到负节点。通过源的电流是未知数之一，定义如下所示： |
| 电流源 | I1 N1 N2 1 | 与电阻类似的注释。电流从节点N1流出，流入节点N2。 |
| 运放 | O1 N1 N2 N3 | 与电阻类似的注释，但具有三个节点，如图所示。 |

定义通过电压源的电流以给出最终电路图：

网表文件是：
```
V1 1 0 12
R1 1 2 1000
R2 2 0 2000
R3 2 0 2000
```

## 示例1：电压

让我们使用我们一直在检查的电路

我们将创建一个包含网表的文本文件：
```
V1 1 0 12
R1 1 2 1000
R2 2 0 2000
R3 2 0 2000
```

并将其保存在MATLAB看到的目录中。我编辑了这样一个文件（使用MATLAB编辑器）并将其保存在我的SCAM目录中，名为example1.cir。要运行程序，将要分析的电路的文件名分配给变量fname，然后调用程序。MATLAB窗口的输出如下所示：

```
>> fname="example1.cir";
>> scam

Started -- please be patient.

Netlist:
V1 1 0 12
R1 1 2 1000
R2 2 0 2000
R3 2 0 2000

The A matrix: 
[  1/R1,              -1/R1, 1]
[ -1/R1, 1/R1 + 1/R2 + 1/R3, 0]
[     1,                  0, 0]

The x matrix: 
  v_1
  v_2
 I_V1

The z matrix:  
  0
  0
 V1

The matrix equation: 
            I_V1 + v_1/R1 - v_2/R1 == 0
 v_2*(1/R1 + 1/R2 + 1/R3) - v_1/R1 == 0
                              v_1 == V1

The solution:  
                                       v_1 == V1
       v_2 == (R2*R3*V1)/(R1*R2 + R1*R3 + R2*R3)
 I_V1 == -(V1*(R2 + R3))/(R1*R2 + R1*R3 + R2*R3)

Elapsed time is 0.308426 seconds.
```

显示网表，然后是A、x和z矩阵以及写出的矩阵方程。最后显示未知变量的值。让我们看看v_2的值（节点2的电压）：

```
>> v_2
v_2 = (R2*R3*V1)/(R1*R2 + R1*R3 + R2*R3)
```

或I_V1（通过电压源的电流）

```
>> I_V1
I_V1 = -(V1*(R2 + R3))/(R1*R2 + R1*R3 + R2*R3)     
```

除了未知数之外，工作区中还创建了几个其他变量（这就是SCAM程序是脚本而不是函数的原因）。创建的重要变量，除了未知数之外，还有对应于每个元素的值。我们可以检查任何元素的值，例如V1或R2

```
>> V1
V1 =    12
	
>> R1
R1 =    1000
```

我们可以使用这些值来获取未知数的数值：

```
>> eval(v_2)
ans =     6
	 
>> eval(I_V1)
ans =   -0.0060
```

这表明节点2的电压是6伏，通过V1的电流是6 mA（进入正节点）。

## 示例2：电流

如果我们对通过R2的电流感兴趣，而不仅仅是节点电压，从节点2到节点0。我们知道通过R2的电流只是R2上的电压降除以电阻值。我们可以符号或数值求解。

```
>> v_2/R2
ans = (R2*R3*V1)/(2000*(R1*R2 + R1*R3 + R2*R3))

>> eval(ans)
ans =    0.0030
```

通过R1的电流，从节点1到节点2，只是R1上的电压除以其值。

```
>> (v_1-v_2)/R1
ans = V1/1000 - (R2*R3*V1)/(1000*(R1*R2 + R1*R3 + R2*R3))

>> eval(ans)
ans =    0.0060
```

其他数量可以类似地确定。例如v_2与V1的比率：

```
>> v_2/V1
ans = (R2*R3*V1)/(12*(R1*R2 + R1*R3 + R2*R3))

>> eval ans
ans = (R2*R3*V1)/(12*(R1*R2 + R1*R3 + R2*R3))
```

## 示例3：生成MNA方程

SCAM程序还定义了来自MNA方法的A、x和z矩阵。

```
>> A
A =
[  1/R1,              -1/R1, 1]
[ -1/R1, 1/R1 + 1/R2 + 1/R3, 0]
[     1,                  0, 0]

>> x
x =
  v_1
  v_2
 I_V1
 
>> z
z =
  0
  0
 V1
```

我们可以使用这些变量重新创建电路方程。要获取方程的左侧，我们只需乘以A*X：

```
>> A*x
ans =
            I_V1 + v_1/R1 - v_2/R1
 v_2*(1/R1 + 1/R2 + 1/R3) - v_1/R1
                               v_1
```

或者，以稍微更容易阅读的形式：

```
>> pretty(A*x)
/             v_1   v_2      \
|      I_V1 + --- - ---      |
|              R1    R1      |
|                            |
|     /  1    1    1 \   v_1 |
| v_2 | -- + -- + -- | - --- |
|     \ R1   R2   R3 /    R1 |
|                            |
\             v_1            /
```

我们甚至可以获取Latex：

```
>> latex(A*x)
ans =
    '\left(\begin{array}{c} I_{\mathrm{V1}}+\frac{v_{1}}{R_{1}}-\frac{v_{2}}{R_{1}}\\ v_{2}\,\left(\frac{1}{R_{1}}+\frac{1}{R_{2}}+\frac{1}{R_{3}}\right)-\frac{v_{1}}{R_{1}}\\ v_{1} \end{array}\right)'
```

方程的左侧由z给出：

```
>> z
z =
  0
  0
 V1
```

使用上面的信息，我们可以获取任何MNA方程。要获取节点2的方程，只需取方程右侧和左侧的第2行：
```
-v_1/R1 + (1/R1 + 1/R2 + 1/R3)v_2 = 0
或 (v_2 - v_1)/R1 + v_2/R2 + v_2/R3 = 0
```

## 示例4：更复杂的电路

我们也可以将程序应用于更复杂的电路，例如以下（来自MNA示例页面的示例3，每个组件都有给定的值）（节点已经标记，通过电压源的电流也标记为清晰）：

这个电路的网表由以下给出：
```
Vg 1 0 4
Vx 3 2 6
R1 1 2 1
R2 2 0 4
R3 3 0 2
It 1 2 1
```

我将这个输入到一个文件中，并将其命名为example4.cir。要分析电路，我们像以前一样进行，通过设置fname变量并启动程序：

```
>> fname='example4.cir';
>> scam

Started -- please be patient.

Netlist:
Vg 1 0 4
Vx 3 2 6
R1 1 2 1
R2 2 0 4
R3 3 0 2
It 1 2 1

The A matrix: 
[  1/R1,       -1/R1,    0, 1,  0]
[ -1/R1, 1/R1 + 1/R2,    0, 0, -1]
[     0,           0, 1/R3, 0,  1]
[     1,           0,    0, 0,  0]
[     0,          -1,    1, 0,  0]

The x matrix: 
  v_1
  v_2
  v_3
 I_Vg
 I_Vx

The z matrix:  
 -It
  It
   0
  Vg
  Vx

The matrix equation: 
           I_Vg + v_1/R1 - v_2/R1 == -It
 v_2*(1/R1 + 1/R2) - v_1/R1 - I_Vx == It
                      I_Vx + v_3/R3 == 0
                               v_1 == Vg
                         v_3 - v_2 == Vx

The solution:  
                                                                      v_1 == Vg
             v_2 == (R2*R3*Vg - R1*R2*Vx + It*R1*R2*R3)/(R1*R2 + R1*R3 + R2*R3)
         v_3 == (R3*(R2*Vg + R1*Vx + R2*Vx + It*R1*R2))/(R1*R2 + R1*R3 + R2*R3)
 I_Vg == -(R2*Vg + R3*Vg + R2*Vx + It*R1*R2 + It*R1*R3)/(R1*R2 + R1*R3 + R2*R3)
            I_Vx == -(R2*Vg + R1*Vx + R2*Vx + It*R1*R2)/(R1*R2 + R1*R3 + R2*R3)

Elapsed time is 0.48674 seconds.
```

我们可以符号或数值求解节点2的电压：

```
>> v_2
v_2 = (R2*R3*Vg - R1*R2*Vx + It*R1*R2*R3)/(R1*R2 + R1*R3 + R2*R3)

>> eval(v_2)
ans =   1.1429
```

我们可以找到通过R1的电流（符号或数值）：

```
>> (v_1-v_2)/R1
ans =
Vg - (R2*R3*Vg - R1*R2*Vx + It*R1*R2*R3)/(R1*R2 + R1*R3 + R2*R3)
>> eval(ans)
ans =
    2.8571
```

我们可以找到节点2的MNA方程：

```
>> q=A*x==z
q =
           I_Vg + v_1/R1 - v_2/R1 == -It
 v_2*(1/R1 + 1/R2) - v_1/R1 - I_Vx == It
                      I_Vx + v_3/R3 == 0
                               v_1 == Vg
                         v_3 - v_2 == Vx

>> q(2)
ans = v_2*(1/R1 + 1/R2) - v_1/R1 - I_Vx == It

>> pretty(q(2))
    /  1    1 \   v_1
v_2 | -- + -- | - --- - I_Vx == It
    \ R1   R2 /    R1
```

或者，以更清晰的格式：
```
v2(1/R1 + 1/R2) - v1/R1 - IVx = It
```

## 示例5：带电阻的运放

下一个示例显示了一个带有2个电阻的标准反相配置的运放及其网表（example5.cir）。

| 电路 | 网表 |
|------|------|
| 电路图 | Vin 3 0 Symbolic<br>R1 1 3 Symbolic<br>R2 2 1 Symbolic<br>OAmp 0 1 2 |

由于我们没有电路中组件的值，它们被声明为"Symbolic"。我们现在可以求解这个电路以确定Vin和节点2之间的增益。

```
>> fname="example5.cir";
>> scam

Started -- please be patient.

Netlist:
Vin 3 0 Symbolic
R1 1 3 Symbolic
R2 2 1 Symbolic
OAmp 0 1 2

The A matrix: 
[ 1/R1 + 1/R2, -1/R2, -1/R1, 0, 0]
[       -1/R2,  1/R2,     0, 0, 1]
[       -1/R1,     0,  1/R1, 1, 0]
[           0,     0,     1, 0, 0]
[          -1,     0,     0, 0, 0]

The x matrix: 
    v_1
    v_2
    v_3
  I_Vin
 I_OAmp

The z matrix:  
   0
   0
   0
 Vin
   0

The matrix equation: 
 v_1*(1/R1 + 1/R2) - v_2/R2 - v_3/R1 == 0
            I_OAmp - v_1/R2 + v_2/R2 == 0
             I_Vin - v_1/R1 + v_3/R1 == 0
                               v_3 == Vin
                                -v_1 == 0

The solution:  
            v_1 == 0
 v_2 == -(R2*Vin)/R1
          v_3 == Vin
    I_Vin == -Vin/R1
    I_OAmp == Vin/R1

Elapsed time is 0.423071 seconds.

>> v_2
